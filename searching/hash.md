# <center> 散列(Hash)

## 定义
散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key
对应一个存储位置f(key).

这个对应关系f就是散列函数，也叫哈希(Hash)函数。

按照这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间
称为散列表或哈希表(Hash Table)。

## 散列查找与存储原理
整个散列过程其实就是两个步骤
1. 在存储时，通过散列函数计算出要保存记录的散列地址，并且在此散列地址上存储该记录
2. 在查找时，通过同样的散列函数再次计算记录的散列地址，然后直接通过这个散列地址来访问
记录。

当然，在存储的时候可能会遇到冲突，就是说多个记录通过散列函数后，都被映射到了同一个
散列地址上，针对这种情况也会有相应的解决办法，这就是冲突解决方案。

## 散列函数的设计原则
1. 散列函数的计算要尽可能的简单
2. 计算出来的散列值要尽可能的分布均匀

## 散列函数的构造方法
1. 直接地址法
> 就是取关键字的某个线性函数值来作为散列地址。即
> f(key) = a*key + b (a,b为常数)
> 
2. 数字分析法

3. 平方取中法
> 对数值进行平方，再抽取中间的几位。
> 
4. 折叠法
> 折叠法是将关键字从左到右分成相等的几份(注意最后一部分倍数不够时可以短一些)，
> 然后再将这几部分叠加求和，并按散列表长度，取后几位当作散列地址。
5. 除留余数法|取模
6. 随机数法

## 散列冲突处理方法
### 开放地址法
开放地址法就是一旦发生的冲突，就以某种方式再到Hash表中寻找下一次空的地址的方法，
只要表的空间足够大，空的散列地址总能够找到，并将记录存入。

**堆积**： 是指本来不是同义词的两个关键字，却发生了冲突的情况。

开放地址法的探测方法：
1. 线性探测
> 公式： f(key) = (f(key) + n) % m 其中m为散列表长度,n的范围[1,2,3...m-1]

2. 二次探测
> 二次探测的目的是为了避免关键字都聚集在某一块区域。
> 
> 公式：f(key) = (f(key) + n) % m 其中n的范围是[1^2, -1^2, 2^2, -2^2...q^2,-q^2, q<=m/2]
3. 随机探测
> 就是在发生冲突的时候，对于位移量n采用随机函数计算得到。
> 
> 这里的n其实是随机数列中依次取出来的。这个随机数列由于在插入和查询的时候使用
> 了相同的种子，所以得到的随机数列也是一样的。
> 
> 这样在发生冲突后，就从随机数列中取出第一项进行探测，如果还是冲突了，就取出第二项
> 就这样探测下去。
> 

### 再散列函数法
事先准备多个散列函数，当发生冲突时，就换一种散列函数，直到没有冲突为止。

公式：f(key) = RH_i(key) 其中i的范围是(1,2,3... k)
> k为散列函数的个数。

### 链地址法
将所有关键字为同义词的记录存储在一个单链表中。这个表称为同义词子表。

### 公共溢出区法
把所有冲突的关键字都存储在一个公共的溢出区中。

在查找时，对给定的值通过散列函数得到地址后，先与散列表中的对应位置的元素比较

如果相等，则查找成功

如果不相等，则到溢出区表进行顺序查找。